import{Audio as e,AudioListener as t,BufferAttribute as s,BufferGeometry as o,Line as i,LineBasicMaterial as a,MathUtils as r,Mesh as l,PositionalAudio as n,SphereGeometry as c}from"THREE";var d={d:(e,t)=>{for(var s in t)d.o(t,s)&&!d.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},u={};d.r(u),d.d(u,{CallLimits:()=>A,callWithReducer:()=>O,clearAllCallReducerData:()=>_,clearCallReducerData:()=>P});var p={};d.r(p),d.d(p,{deepDispose:()=>x,disposeMaterials:()=>v});var m={};d.r(m),d.d(m,{deepMerge:()=>E,getObjectDiff:()=>T,patchObject:()=>C});var f={};d.r(f),d.d(f,{TimePattern:()=>V,formatTime:()=>z});var y={};d.r(y),d.d(y,{getUniqueId:()=>k});var M={};d.r(M),d.d(M,{absVector3:()=>U});var h={};d.r(h),d.d(h,{isPointInATriangle:()=>I,sign:()=>w,yFromTriangle:()=>D});var S={};d.r(S),d.d(S,{getAudioBuffer:()=>G,getTexture:()=>B,registerAudioBuffer:()=>F,registerTexture:()=>N});var g={};d.r(g),d.d(g,{default:()=>ie,getAudioCache:()=>$,playAudio:()=>K,setAudioConfig:()=>J,setEffectsVolume:()=>oe,setMasterVolume:()=>te,setMusicVolume:()=>se,stopAudio:()=>Q});const A={NO_LIMIT:-1,CALL_1_PER_SECONDS:1e3,CALL_15_PER_SECONDS:1e3/15,CALL_30_PER_SECONDS:1e3/30,CALL_45_PER_SECONDS:1e3/45,CALL_60_PER_SECONDS:1e3/60,CALL_120_PER_SECONDS:1e3/120};let b={};const O=({id:e,callback:t,callLimit:s,elapsed:o,callbackParam:i,forceCallCount:a=!1})=>{if(!o)return;b[e]||(b[e]={lastUpdate:-1,callCount:0});const r=()=>{i?t(i):t()};if(s!==A.NO_LIMIT)if(a){const t=Math.floor(o/(1e3*s));for(;-1===b[e].lastUpdate||t>b[e].callCount;)r(),b[e].lastUpdate+=s,b[e].callCount++;b[e].lastUpdate=o}else(-1===b[e].lastUpdate||o-b[e].lastUpdate>=s)&&(r(),b[e].lastUpdate=o);else r()},P=e=>delete b[e],_=()=>{b={}},v=e=>{if(e.isMaterial){const t=e;t.map?.dispose(),t.map=null,t.dispose()}else e.forEach(v)},x=e=>{const{isMesh:t,material:s,geometry:o}=e;t?(s&&(v(s),e.material=null),o&&(o.dispose(),e.geometry=null),e.parent?.remove(e)):e.children&&(e.children.forEach(x),e.parent?.remove(e))},C=(e,t,s={skippedProperties:[],applyToFirstObject:!1})=>{const o={};return Object.keys(e).forEach(i=>{s.skippedProperties&&s.skippedProperties.includes(i)||("object"==typeof e[i]&&e[i]&&t[i]&&!Array.isArray(e[i])?o[i]=C(e[i],t[i],s):(o[i]=0===t[i]?0:!1!==t[i]&&(t[i]||e[i]),s.applyToFirstObject&&(e[i]=o[i])))}),o},E=(e,t,s={skippedProperties:[],applyToFirstObject:!1})=>{const o={};return Array.from(new Set([...Object.keys(e||{}),...Object.keys(t||{})])).forEach(i=>{s.skippedProperties&&s.skippedProperties.includes(i)||("object"==typeof e?.[i]&&e?.[i]&&t?.[i]&&!Array.isArray(e[i])?o[i]=E(e[i],t[i],s):(o[i]=0===t?.[i]?0:!1!==t?.[i]&&(t?.[i]||e?.[i]),s.applyToFirstObject&&(e[i]=o[i])))}),o},T=(e,t,s={skippedProperties:[]})=>{const o={};return Object.keys(e).forEach(i=>{if(!s.skippedProperties||!s.skippedProperties.includes(i))if("object"==typeof e[i]&&e[i]&&t[i]&&!Array.isArray(e[i])){const a=T(e[i],t[i],s);Object.keys(a).length>0&&(o[i]=a)}else{const s=0===t[i]?0:t[i]||e[i];s!==e[i]&&(o[i]=s)}}),o},V={HH_MM_SS:"HH:MM:SS",MM_SS:"MM:SS",MM_SS_MS:"MM:SS.MS"},j=[{pattern:"HH",routine:({hours:e})=>String(e).padStart(2,"0")},{pattern:"MM",routine:({minutes:e})=>String(e).padStart(2,"0")},{pattern:"SS",routine:({seconds:e})=>String(e).padStart(2,"0")},{pattern:"MS",routine:({milliseconds:e})=>String(e).padStart(3,"0")}],z=(e,t)=>{const s=Math.floor(e%1e3),o=Math.floor(e/1e3%60),i=Math.floor(Math.floor(e/1e3/60)%60),a={hours:Math.floor(Math.floor(e/1e3/60)/60%24),minutes:i,seconds:o,milliseconds:s};let r=t;return j.forEach(({pattern:e,routine:t})=>r=r.replace(e,t(a))),r};let L=0;const k=()=>L++,U=e=>(e.x=Math.abs(e.x),e.y=Math.abs(e.y),e.z=Math.abs(e.z),e),w=(e,t,s)=>(e.x-s.x)*(t.z-s.z)-(t.x-s.x)*(e.z-s.z),I=(e,t,s,o)=>{const i=w(e,t,s),a=w(e,s,o),r=w(e,o,t);return!((i<0||a<0||r<0)&&(i>0||a>0||r>0))},D=(e,t,s,o)=>{const i=(s.x-t.x)*(o.y-t.y)-(o.x-t.x)*(s.y-t.y),a=(s.x-t.x)*(o.z-t.z)-(o.x-t.x)*(s.z-t.z),r=(s.z-t.z)*(o.y-t.y)-(o.z-t.z)*(s.y-t.y),l=(s.x-t.x)*(o.z-t.z)-(o.x-t.x)*(s.z-t.z);return t.y+i/a*(e.z-t.z)-r/l*(e.x-t.x)},R=new Map,H=new Map,N=(e,t)=>{R.set(e,t)},B=e=>R.get(e)||null,F=(e,t)=>{H.set(e,t)},G=e=>H.get(e)||null;class X extends i{constructor(e,t=1,i=16,r=2){const l=new o,n=new Float32Array(3*(3*(i+2*r)+3));l.setAttribute("position",new s(n,3));const c=new a({color:65280});super(l,[new a({color:16776960}),c]),this.audio=e,this.range=t,this.divisionsInnerAngle=i,this.divisionsOuterAngle=r,this.type="PositionalAudioHelper",this.update()}update(){const e=this.audio,t=this.range,s=this.divisionsInnerAngle,o=this.divisionsOuterAngle,i=r.degToRad(e.panner.coneInnerAngle),a=r.degToRad(e.panner.coneOuterAngle),l=i/2,n=a/2;let c,d,u=0,p=0;const m=this.geometry,f=m.attributes.position;function y(e,s,o,i){const a=(s-e)/o;for(f.setXYZ(u,0,0,0),p++,c=e;c<s;c+=a)d=u+p,f.setXYZ(d,Math.sin(c)*t,0,Math.cos(c)*t),f.setXYZ(d+1,Math.sin(Math.min(c+a,s))*t,0,Math.cos(Math.min(c+a,s))*t),f.setXYZ(d+2,0,0,0),p+=3;m.addGroup(u,p,i),u+=p,p=0}m.clearGroups(),y(-n,-l,o,0),y(-l,l,s,1),y(l,n,o,0),f.needsUpdate=!0,i===a&&(this.material[0].visible=!1)}dispose(){this.geometry.dispose(),this.material[0].dispose(),this.material[1].dispose()}}const Y={loop:!1,volume:1,isMusic:!1};let Z={};const q={},W={masterVolume:1,musicVolume:1,effectsVolume:1},J=e=>{Z=e},K=({audioId:s,position:o,radius:i=1,scene:a,camera:r,cacheId:d})=>{const u=Date.now();let p;if(d&&q[d]){const{audio:e,container:t}=q[d];p=e,p.isPlaying&&p.stop(),t&&o&&t.position.copy(o),q[d].lastPlayedTime=u}else{const m=G(s);if(!m)return;const{loop:f,volume:y,isMusic:M}={...Y,...Z[s]},h=new t;let S;if(o&&a&&r){p=new n(h),p.setRefDistance(i);const e=new c(i,32,32);S=new l(e),S.visible=!1;const t=new X(p,i);p.add(t),S.position.copy(o),S.add(p),a.add(S),r.add(h)}else p=new e(h);p.setBuffer(m),p.setLoop(f||!1),p.setVolume((y||1)*W.masterVolume*(M?W.musicVolume:W.effectsVolume)),q[d||s]={audio:p,audioId:s,container:S,lastPlayedTime:u}}p.play()},Q=e=>{const t=$(e);t.audio&&t.audio.isPlaying&&t.audio.stop()},$=e=>q[e]||{audio:null,audioId:"",container:void 0,lastPlayedTime:0},ee=()=>{Object.keys(q).forEach(e=>{const{audio:t,audioId:s}=$(e);if(t){const{volume:e,isMusic:o}={...Y,...Z[s]};t.setVolume((e||1)*W.masterVolume*(o?W.musicVolume:W.effectsVolume))}})},te=e=>{W.masterVolume=e,ee()},se=e=>{W.musicVolume=e,ee()},oe=e=>{W.effectsVolume=e,ee()},ie={playAudio:K,stopAudio:Q,setMasterVolume:te,setMusicVolume:se,setEffectsVolume:oe};export{S as AssetsUtils,g as AudioUtils,u as CallbackUtils,p as DisposeUtils,h as GeomUtils,m as ObjectUtils,f as TimeUtils,y as TokenUtils,M as Vector3Utils};